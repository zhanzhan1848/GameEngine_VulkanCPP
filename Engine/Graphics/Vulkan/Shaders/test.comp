#version 450
#include "Common.h"

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = 0, binding = 0) buffer StorageBuffer
{
	GlobalShaderData ubo;
} global_data;

//layout(set = 0, binding = 1) uniform writeonly image2D OutputImage;

layout(set = 0, binding = 1) writeonly buffer OutputFrustum
{
	Frustum Frustums[];
} outputFrustum;

#if USE_BOUNDING_SPHERES
void main()
{
	if(gl_GlobalInvocationID.x >= 100 || gl_GlobalInvocationID.y >= 57) return;

	vec2 invViewDimensions = 16 / vec2(global_data.ubo.ViewWidth, global_data.ubo.ViewHeight);
	vec2 topLeft = gl_GlobalInvocationID.xy * invViewDimensions;
	vec2 center = topLeft + (invViewDimensions * 0.5);

	vec3 topLeftVS = UnprojectUV(topLeft, 0, global_data.ubo.InvProjection).xyz;
	vec3 centerVS = UnprojectUV(center, 0, global_data.ubo.InvProjection).xyz;

	float farClipRcp = -global_data.ubo.InvProjection[3][3];
	Frustum frustum = { normalize(centerVS), distance(centerVS, topLeftVS) * farClipRcp };
	outputFrustum.Frustums[gl_GlobalInvocationID.x + (gl_GlobalInvocationID.y * 100)] = frustum;
}
#else
void main()
{
	uint x = gl_GlobalInvocationID.x;
	uint y = gl_GlobalInvocationID.y;

	if(x >= 100 || y >= 57) return;
	
	vec4 screenSpace[4];
	screenSpace[0] = vec4(vec2(x, y) * 16, 0.0, 1.0);
	screenSpace[1] = vec4(vec2(x + 1, y) * 16, 0.0, 1.0);
	screenSpace[2] = vec4(vec2(x, y + 1) * 16, 0.0, 1.0);
	screenSpace[3] = vec4(vec2(x + 1, y + 1) * 16, 0.0, 1.0);
	
	vec2 invViewDimensions = vec2(1.0) / vec2(global_data.ubo.ViewWidth, global_data.ubo.ViewHeight);
	
	vec3 viewSpace[4];
	viewSpace[0] = ScreenToView(screenSpace[0], invViewDimensions, global_data.ubo.InvProjection).xyz;
	viewSpace[1] = ScreenToView(screenSpace[1], invViewDimensions, global_data.ubo.InvProjection).xyz;
	viewSpace[2] = ScreenToView(screenSpace[2], invViewDimensions, global_data.ubo.InvProjection).xyz;
	viewSpace[3] = ScreenToView(screenSpace[3], invViewDimensions, global_data.ubo.InvProjection).xyz;
	
	vec3 eyePos =  vec3(0.0);
	Frustum frustum;
	// frustum.Planes[0] = ComputePlane(eyePos, viewSpace[2], viewSpace[0]);
	// frustum.Planes[1] = ComputePlane(eyePos, viewSpace[1], viewSpace[3]);
	// frustum.Planes[2] = ComputePlane(eyePos, viewSpace[0], viewSpace[1]);
	// frustum.Planes[3] = ComputePlane(eyePos, viewSpace[3], viewSpace[2]);

	frustum.Planes[0] = ComputePlane(viewSpace[0], eyePos, viewSpace[2]);
	frustum.Planes[1] = ComputePlane(viewSpace[3], eyePos, viewSpace[1]);
	frustum.Planes[2] = ComputePlane(viewSpace[1], eyePos, viewSpace[0]);
	frustum.Planes[3] = ComputePlane(viewSpace[2], eyePos, viewSpace[3]);

	outputFrustum.Frustums[x + (y * 100)] = frustum;

	// imageStore(OutputImage, ivec2(gl_GlobalInvocationID.xy), vec4(frustum.Planes[(x + (y * 100)) % 4].normal, 1.0));
}
#endif