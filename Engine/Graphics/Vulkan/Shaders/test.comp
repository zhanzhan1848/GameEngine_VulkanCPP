#version 450

struct Plane
{
	vec3 normal;
	float distance;
};

struct Frustum
{
	Plane Planes[4];
};

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = 0, binding = 0) buffer StorageBuffer
{
	mat4	model;
	mat4	view;
	mat4	projection;
	vec3	cameraDir;
    vec3    cameraPos;
	float	near;
	float	far;
} global_data;

//layout(set = 0, binding = 1, rgba8) uniform writeonly image2D OutputImage;

layout(set = 0, binding = 1) writeonly buffer OutputFrustum
{
	Frustum Frustums[];
} outputFrustum;

Plane ComputePlane(vec3 p0, vec3 p1, vec3 p2)
{
	Plane plane;
	vec3 v0 = p1 - p0;
	vec3 v2 = p2 - p0;

	plane.normal = normalize(cross(v0, v2));
	plane.distance = dot(plane.normal, p0);
	return plane;
}

vec4 ClipToView(vec4 clip, mat4 inverseProjection)
{
	vec4 view = inverseProjection * clip;
	view /= view.w;
	return view;
}

vec4 ScreenToView(vec4 screen, vec2 invViewDimensions, mat4 inverseProjection)
{
	vec2 texCoord = screen.xy * invViewDimensions;
	vec4 clip = vec4(vec2(texCoord.x, 1.0 - texCoord.y) * 2.0 - 1.0, screen.z, screen.w);
	return ClipToView(clip, inverseProjection);
}

void main()
{
	uint x = gl_GlobalInvocationID.x;
	uint y = gl_GlobalInvocationID.y;

	if(x >= 100 || y >= 57) return;
	
	vec4 screenSpace[4];
	screenSpace[0] = vec4(vec2(x, y) * 16, 0.0, 1.0);
	screenSpace[1] = vec4(vec2(x + 1, y) * 16, 0.0, 1.0);
	screenSpace[2] = vec4(vec2(x, y + 1) * 16, 0.0, 1.0);
	screenSpace[3] = vec4(vec2(x + 1, y + 1) * 16, 0.0, 1.0);
	
	vec2 invViewDimensions = vec2(1.0) / vec2(1600.0, 900.0);
	
	vec3 viewSpace[4];
	mat4 invProjection = inverse(global_data.projection);
	viewSpace[0] = ScreenToView(screenSpace[0], invViewDimensions, invProjection).xyz;
	viewSpace[1] = ScreenToView(screenSpace[1], invViewDimensions, invProjection).xyz;
	viewSpace[2] = ScreenToView(screenSpace[2], invViewDimensions, invProjection).xyz;
	viewSpace[3] = ScreenToView(screenSpace[3], invViewDimensions, invProjection).xyz;
	
	vec3 eyePos = vec3(0.0);
	Frustum frustum;
	frustum.Planes[0] = ComputePlane(viewSpace[0], eyePos, viewSpace[2]);
	frustum.Planes[1] = ComputePlane(viewSpace[3], eyePos, viewSpace[1]);
	frustum.Planes[2] = ComputePlane(viewSpace[1], eyePos, viewSpace[0]);
	frustum.Planes[3] = ComputePlane(viewSpace[2], eyePos, viewSpace[3]);

	outputFrustum.Frustums[x + (y * 100)] = frustum;

	//imageStore(OutputImage, ivec2(gl_GlobalInvocationID.xy), vec4(frustum.Planes[x % 4].normal, 1.0));
}