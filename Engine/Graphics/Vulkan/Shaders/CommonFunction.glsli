

// 法线分布函数
float DistributionGGX(vec3 N, vec3 H, float a)
{
	float a2 = a * a * a * a;
	float NdotH = max(dot(N, H), 0.0);
	float NdotH2 = NdotH * NdotH;

	float nom = a2;
	float denom = (NdotH2 * (a2 - 1.0) + 1.0);
	denom = 3.1415926535897932384626433832795 * denom * denom;

	return nom / denom;
}

// 几何函数
float GeometrySchlickGGX(float NdotV, float k)
{
	float r = k + 1.0;
	float a = (r * r) / 8.0;

	float nom = NdotV;
	float denom = NdotV * (1.0 - k) + k;

	return nom / denom;
}

float GeometrySmith(vec3 N, vec3 V, vec3 L, float k)
{
	float NdotV = max(dot(N, V), 0.0);
	float NdotL = max(dot(N, L), 0.0);
	float ggx1 = GeometrySchlickGGX(NdotV, k);
	float ggx2 = GeometrySchlickGGX(NdotL, k);

	return ggx1 * ggx2;
}

// 菲涅尔方程
vec3 fresnelSchlick(float cosTheta, vec3 F0)
{
	return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

// view to projection
vec4 projectToScreenSpace(vec3 point, mat4 projection)
{
	return projection * vec4(point, 1.0);
}

// world to view
vec3 projectToViewSpace(vec3 point, mat4 view)
{
	return (view * vec4(point, 1.0)).xyz;
}

// 计算像素距离
float distanceSquared(vec2 A, vec2 B)
{
	A -= B;
	return dot(A, A);
}

// 判断是否被遮挡
// bool query(vec2 z, vec2 uv, int width, int height)
// {
// 	float depths = texture(samplers[0], uv / vec2(width, height)).a;
// 	return z.y < depths && z.x > depths;
// }

// SSR
struct Result
{
	bool IsHit;

	vec2 UV;
	vec3 pos;

	int IterationCount;
};

struct Ray
{
	vec3 origin;
	vec3 direction;
};

// Result RayMarching(Ray r, int width, int height)
// {
// 	Result result;
// 	vec3 Begin = r.origin;
// 	vec3 End = r.origin + r.direction * 10000;
// 
// 	vec3 v0 = projectToViewSpace(Begin);
// 	vec3 v1 = projectToViewSpace(End);
// 
// 	vec4 H0 = projectToScreenSpace(v0);
// 	vec4 H1 = projectToScreenSpace(v1);
// 
// 	float k0 = 1.0 / H0.w;
// 	float k1 = 1.0 / H1.w;
// 
// 	vec3 Q0 = v0 * k0;
// 	vec3 Q1 = v1 * k1;
// 
// 	vec2 P0 = H0.xy * k0;
// 	vec2 P1 = H1.xy * k1;
// 
// 	vec2 Size = vec2(width, height);
// 	P0 = (P0 + 1) / 2 * Size;
// 	P1 = (P1 + 1) / 2 * Size;
// 
// 	P1 += vec2((distanceSquared(P0, P1) < 0.0001) ? 0.01 : 0.0);
// 	
// 	vec2 delta = P1 - P0;
// 	bool Permute = false;
// 	if(abs(delta.x) < abs(delta.y))
// 	{
// 		Permute = true;
// 		delta = delta.yx;
// 		P0 = P0.yx;
// 		P1 = P1.yx;
// 	}
// 	float stepDir = sign(delta.x);
// 	float invdx = stepDir / delta.x;
// 	vec3 dQ = (Q1 - Q0) * invdx;
// 	float dk = (k1 - k0) * invdx;
// 	vec2 dP = vec2(stepDir, delta.y * invdx);
// 	float stride = 1.0f;
// 
// 	dP *= stride; dQ *= stride; dk *= stride;
// 	P0 += dP; Q0 += dQ; k0 += dk;
// 
// 	int step = 0;
// 	int maxstep = 500;
// 	float k = k0;
// 	float endx = P1.x * stepDir;
// 	vec3 Q = Q0;
// 	float prevZMaxEstimate = v0.z;
// 
// 	for(vec2 P = P0; step < maxstep; step++, P += dP, Q.z += dQ.z, k += dk)
// 	{
// 		result.UV = Permute ? P.yx : P;
// 		vec2 Depths;
// 		Depths.x = prevZMaxEstimate;
// 		Depths.y = (dQ.z * 0.5 + Q.z) / (dk * 0.5 + k);
// 		prevZMaxEstimate = Depths.y;
// 		if(Depths.x < Depths.y)
// 		{
// 			Depths.xy = Depths.yx;
// 		}
// 		if(result.UV.x > 1600 || result.UV.x < 0 || result.UV.y > 900 || result.UV.y < 0)
// 		{
// 			break;
// 		}
// 		result.IsHit = query(Depths, result.UV, width, height);
// 		if(result.IsHit) { break; }
// 	}
// 
// 	return result;
// }


// Light Culling
// Check to see if a point is fully behind (inside the negative halfspace of) a plane
bool PointInsidePlane(vec3 p, Plane plane)
{
    return dot(plane.Normal, p) - plane.Distance < 0;
}

// Check to see if a sphere is fully behind (inside the negative halfspace of) a plane
// Source: Real-time collision detection, Christer Ericson(2005)
bool SphereInsidePlane(Sphere sphere, Plane plane)
{
    return dot(plane.Normal, sphere.Center) - plane.Distance < -sphere.Radius;
}

// Check to see if a cone if fully behind (inside the negative halfspace of) a plane
// Source:: Real-time collision detection, Christer Ericson(2005)
bool ConeInsidePlane(Cone cone, Plane plane)
{
    // Compute the farthest point on the end of the cone to the positive space of the plane
    vec3 m = cross(cross(plane.Normal, cone.Direction), cone.Direction);
    vec3 Q = cone.Tip + cone.Direction * cone.Height - m * cone.Radius;

    // The cone is in the negative halfspace of the plane if both
    // the tip of the cone and the farthest point on the end of the cone to the
    // positive halfspce of the plane are both inside the negative halfspace
    // of the plane
    return PointInsidePlane(cone.Tip, plane) && PointInsidePlane(Q, plane);
}

// Check to see of a light is partially contained within the function
bool SphereInsideFrustum(Sphere sphere, Frustum frustum, float zNear, float zFar)
{
    // First check depth
    // Note: Here, the view vector points in the -Z axis so the
    // far depth value will be approaching -infinity.
    return !((sphere.Center.z - sphere.Radius > zNear || sphere.Center.z + sphere.Radius < zFar) ||
                SphereInsidePlane(sphere, frustum.Planes[0]) ||
                SphereInsidePlane(sphere, frustum.Planes[1]) ||
                SphereInsidePlane(sphere, frustum.Planes[2]) ||
                SphereInsidePlane(sphere, frustum.Planes[3]));
}

bool ConeInsideFrustum(Cone cone, Frustum frustum, float zNear, float zFar)
{
    bool result = true;

    Plane nearPlane = { vec3(0, 0, -1), -zNear };
    Plane farPlane = { vec3(0, 0, 1), -zFar };

    // First check the near and far clipping planes
    if(ConeInsidePlane(cone, nearPlane) || ConeInsidePlane(cone, farPlane))
    {
        result = false;
    }

    // Then check frustum planes
    for(int i = 0; i < 4 && result; i++)
    {
        if(ConeInsidePlane(cone, frustum.Planes[i]))
        {
            result = false;
        }
    }
    return result;
}