

// 法线分布函数
float DistributionGGX(vec3 N, vec3 H, float a)
{
	float a2 = a * a * a * a;
	float NdotH = max(dot(N, H), 0.0);
	float NdotH2 = NdotH * NdotH;

	float nom = a2;
	float denom = (NdotH2 * (a2 - 1.0) + 1.0);
	denom = 3.1415926535897932384626433832795 * denom * denom;

	return nom / denom;
}

// 几何函数
float GeometrySchlickGGX(float NdotV, float k)
{
	float r = k + 1.0;
	float a = (r * r) / 8.0;

	float nom = NdotV;
	float denom = NdotV * (1.0 - k) + k;

	return nom / denom;
}

float GeometrySmith(vec3 N, vec3 V, vec3 L, float k)
{
	float NdotV = max(dot(N, V), 0.0);
	float NdotL = max(dot(N, L), 0.0);
	float ggx1 = GeometrySchlickGGX(NdotV, k);
	float ggx2 = GeometrySchlickGGX(NdotL, k);

	return ggx1 * ggx2;
}

// 菲涅尔方程
vec3 fresnelSchlick(float cosTheta, vec3 F0)
{
	return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

// view to projection
vec4 projectToScreenSpace(vec3 point, mat4 projection)
{
	return projection * vec4(point, 1.0);
}

// world to view
vec3 projectToViewSpace(vec3 point, mat4 view)
{
	return (view * vec4(point, 1.0)).xyz;
}

// 计算像素距离
float distanceSquared(vec2 A, vec2 B)
{
	A -= B;
	return dot(A, A);
}

// 判断是否被遮挡
// bool query(vec2 z, vec2 uv, int width, int height)
// {
// 	float depths = texture(samplers[0], uv / vec2(width, height)).a;
// 	return z.y < depths && z.x > depths;
// }

// SSR
struct Result
{
	bool IsHit;

	vec2 UV;
	vec3 pos;

	int IterationCount;
};

struct Ray
{
	vec3 origin;
	vec3 direction;
};

// Result RayMarching(Ray r, int width, int height)
// {
// 	Result result;
// 	vec3 Begin = r.origin;
// 	vec3 End = r.origin + r.direction * 10000;
// 
// 	vec3 v0 = projectToViewSpace(Begin);
// 	vec3 v1 = projectToViewSpace(End);
// 
// 	vec4 H0 = projectToScreenSpace(v0);
// 	vec4 H1 = projectToScreenSpace(v1);
// 
// 	float k0 = 1.0 / H0.w;
// 	float k1 = 1.0 / H1.w;
// 
// 	vec3 Q0 = v0 * k0;
// 	vec3 Q1 = v1 * k1;
// 
// 	vec2 P0 = H0.xy * k0;
// 	vec2 P1 = H1.xy * k1;
// 
// 	vec2 Size = vec2(width, height);
// 	P0 = (P0 + 1) / 2 * Size;
// 	P1 = (P1 + 1) / 2 * Size;
// 
// 	P1 += vec2((distanceSquared(P0, P1) < 0.0001) ? 0.01 : 0.0);
// 	
// 	vec2 delta = P1 - P0;
// 	bool Permute = false;
// 	if(abs(delta.x) < abs(delta.y))
// 	{
// 		Permute = true;
// 		delta = delta.yx;
// 		P0 = P0.yx;
// 		P1 = P1.yx;
// 	}
// 	float stepDir = sign(delta.x);
// 	float invdx = stepDir / delta.x;
// 	vec3 dQ = (Q1 - Q0) * invdx;
// 	float dk = (k1 - k0) * invdx;
// 	vec2 dP = vec2(stepDir, delta.y * invdx);
// 	float stride = 1.0f;
// 
// 	dP *= stride; dQ *= stride; dk *= stride;
// 	P0 += dP; Q0 += dQ; k0 += dk;
// 
// 	int step = 0;
// 	int maxstep = 500;
// 	float k = k0;
// 	float endx = P1.x * stepDir;
// 	vec3 Q = Q0;
// 	float prevZMaxEstimate = v0.z;
// 
// 	for(vec2 P = P0; step < maxstep; step++, P += dP, Q.z += dQ.z, k += dk)
// 	{
// 		result.UV = Permute ? P.yx : P;
// 		vec2 Depths;
// 		Depths.x = prevZMaxEstimate;
// 		Depths.y = (dQ.z * 0.5 + Q.z) / (dk * 0.5 + k);
// 		prevZMaxEstimate = Depths.y;
// 		if(Depths.x < Depths.y)
// 		{
// 			Depths.xy = Depths.yx;
// 		}
// 		if(result.UV.x > 1600 || result.UV.x < 0 || result.UV.y > 900 || result.UV.y < 0)
// 		{
// 			break;
// 		}
// 		result.IsHit = query(Depths, result.UV, width, height);
// 		if(result.IsHit) { break; }
// 	}
// 
// 	return result;
// }